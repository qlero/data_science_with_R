---
title: "poisson_processes"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE, echo = TRUE)
```

# 1 - Homogeneous Poisson processes

## Overview

**Let's generate several homogeneous Poisson processes and provide raster and trajectory plots for comparison. Let's further discuss afterwards.**
    
## Implementation
    
### Goal

Our goal is to introduce several simulation of homogeneous Poisson processes (a special case of continuous time Markov chains) and plot them using raster and trajectory plots and comment on possible observations. To create trajectory plots, we will rely on base R while raster plots will be generated with the `STAR` library.

```{r library_imports, results=FALSE,  message=FALSE}

#install.packages("STAR")
library(STAR)

```

### Method

We recall the definition of a homogeneous Poisson process with parameter $r$. 

- We yield a homogeneous Poisson process if the independent and identically distributed random variables $\forall k \in\mathbb{N},\,\tilde{T}^k~\mathcal{E}(r)$, the exponential distribution with parameter $r$.

\begin{align}
\forall k \in\mathbb{N},\,\tilde{T}^k&~\mathcal{E}(r)\\
\forall j \in\mathbb{N}_+,\,T^j &= \overset{j}{\underset{k=1}{\sum}}\tilde{T}^k\\
T^0&=\tilde{T}^0\\
N_t&=k\quad\quad\text{(a counter s.t. $t\in[T^k,T^{k+1}]$)}
\end{align}

### Results

We start by declaring our functions:

1. function to generate homogeneous Poisson processes:

```{r simulation_function}

homogeneous_poisson_process_simulation <- function(
  parameter, process_length, simulation_number
){
  ### Generates <simulation_number> homogeneous Poisson process simulations 
  ### with parameter <parameter> as input, with a maximum process length of
  ### <process_length>.
  #
  # Samples <process_length> exponential distribution with parameter 
  # <parameter> a <simulation_number> number of times.
  # Yiels a <simulation_number>*<process_length> matrix of IID exponential
  # random variables. It corresponds to the list of \tilde{T}^k used to 
  # build a homogeneous Poisson process
  simulations = matrix(rexp(process_length*simulation_number, parameter), 
                       nrow = simulation_number, ncol = process_length)
  # Adds the 0-column
  simulations = cbind(matrix(0,nrow = simulation_number, ncol=1), simulations)
  # Performs a row-wise cumulative sum to yield the list of T^j corresponding 
  # to a homogeneous Poisson process
  simulations = t(apply(simulations, 1, cumsum))
  # Computes the counter
  counter = c(0:process_length)
  # Returns
  return(list("counter"=counter, "simulations"=simulations))
}

```

2. function to generate the trajectory plot:

```{r trajectory_plot}

plot_trajectories <- function(poisson_processes, parameter) {
  ### Generates a trajectory plot for the first four instances of a list of
  ### Poisson processes.
  #
  # Generates the counter values
  counter = c(0:(dim(poisson_processes)[2]-1))
  # Plots
  plot(poisson_processes[1,],counter,type="S",col=2,lwd=1,
       xlab="Time", ylab="N (counter)",
       xlim=c(0, round(max(c(poisson_processes[1:10,])))+1/parameter),
       main=paste("Trajectories of the first 10 homogeneous\nPoisson procs. ~ Exp(",
                  parameter,")",sep=""))
  for (i in 2:10) {
    lines(poisson_processes[i,],counter,type="S",lwd=1,col=i+1)
  }
}

```

3. function to generate the raster plot:

<u>Of note:</u> By default, we restrict the visualization of raster plots to a given x-axis window limited to the interval $[0, T^j_{min}]$, with $T^j_{min}$ the minimum amount of time any simulated homogeneous Poisson process reached a pre-selected last step/jump (i.e. the maximum jump, starting at 0 and incrementing by jumps of 1, after which we stop a homogeneous Poisson process simulation). This maximum variable corresponds to the variable `process_length` used as input for our simulation function `homogeneous_poisson_process_simulation`.

The rationale is that, as Poisson processes go towards this maximum amount of steps `process_length`, the spike train ticks displayed in a raster plot would start thinning out, which might lead a user to erroneous conclusions if they perform visual analysis. 

An example without this interval bound will be given in comments.

```{r raster_plot}

plot_rasters <- function(poisson_processes, parameter,restrict_xlim=F) {
  ### Generates a raster plot for the first 100 instances of a list of 
  ### Poisson processes.
  #
  # Transforms the matrix of poisson process into a list
  col_length = dim(poisson_processes)[2]
  sims = t(poisson_processes[,2:col_length])
  trains = split(sims, rep(1:ncol(sims), each = nrow(sims)))
  trains = as.repeatedTrain(trains[1:100])
  # Plots the raster plot
  title = paste0("Raster plot of the first 100 homoge-\nneous",
             " Poisson procs. ~ Exp(", parameter,")")
  if (restrict_xlim){
    plot(trains, colStim = "grey80", main=title, 
         ylab="Trials", yaxt="n",
         xlim=c(0,min(round(poisson_processes[,col_length])+1)))
  } else {
    plot(trains, colStim = "grey80", main=title, 
         ylab="Trials", yaxt="n")
  }
}

```

We generate simulations with varying parameters and display the results with trajectory plots:

```{r simulate_and_plot_trajectories, out.width="100%"}

n_simulations = 1000
simulation_length = 10 # corresponds to a maximum counter/number of jumps
parameters = matrix(c(0.1, 1, 2, 10))

simulations = apply(parameters, 1, function(x) {
  homogeneous_poisson_process_simulation(
    x,simulation_length,n_simulations
  )
})

par(mfrow=c(2,2))
for (i in 1:length(parameters)){
  plot_trajectories(simulations[[i]]$simulations, parameters[i])
}

```

We then display the results with raster plots each time with the whole simulations or only the first one hundred trains:

```{r simulate_and_plot_rasters, out.width="100%"}

par(mfrow=c(2,2))
for (i in 1:length(parameters)){
  plot_rasters(simulations[[i]]$simulations, parameters[i], restrict_xlim = T)
}

```

### Comments

As previously mentioned in note, we have based our homogeneous Poisson process modeling on the exponential distribution. Moreover, for simulation purposes, a maximum amount of state jumps (from 0 to 1, then 1 to 2, etc.) was also stated, which led us to restrict our plot visualization to a given x-axis window (starting at $x=0$ and stopping at $T^j_{min}$, the lowest amount of time a simulation batch needed to reach the last state jump).

As mentioned, we did that to erase from visualization the trailing end of the graph where the spike trains stop/thin out as they are reaching their maximum iteration one after the other.

Without this window restriction, we would see the following behavior at the right end of the graph -- which results from our simulation choices rather than from expected spike train behaviors, thus why we remove those tails values.

```{r simulate_and_plot_2}

n_simulations = 100
simulation_length = 200 # corresponds to a maximum counter/number of jumps

simulation = homogeneous_poisson_process_simulation(
  10,simulation_length,n_simulations
)

plot_rasters(simulation$simulations, 10, restrict_xlim = F)

```

Beyond this, we can assess visually that we are indeed generating homogeneous processes as no given behavior arises from the generated batches of Poisson process simulation, despite varying the parameter $r$ of the underlying exponential distribution.

# 1 - Inhomogeneous Poisson processes

## Overview

**Let's choose a non-constant rate function $r(t)$ and:**

1. **Implement a so-called poor and robust algorithm to simulate an inhomogeneous poisson process with rate $r(t)$**

2. **Implement an algorithm with a rejection procedure to simulate an inhomogeneous poisson process with rate $r(t)$**

<u>Note:</u> Let's compare the two implementations in terms of time complexity/efficiency afterwards
    
## Implementation
    
As a non-constant rate function $r(t)$, we decide on a sinusoidal function $r$ (with a scale factor of $10$ w.r.t. the time parameter) such that:

$$r(t)=\cos(t+\pi)+1$$

The rationale is to start with a rate function with $r(0) = 0$ to conserve the $T^j=0$ condition of Poisson processes at $j=0$ as part of our simulation process.

We declare two non-constant rate functions as examples and plot them:

```{r non_constant_r_function, out.width="100%"}

rate_function_1 <- function(t, normalization_factor) {
  (cos(t+pi)+1)/normalization_factor
}

rate_function_2 <- function(t, normalization_factor) {
  # This function will produce some NAs when used as input to the mapper in
  # the function inhomogeneous_poor_robust_algorithm below, those will be
  # replaced with 0s.
  if ((t>5 && t<20) || (t>45 && t<50)) {scale = 100} else {scale = 1}
  ret = (abs(tan(t))+1)
  if (ret<2) {0} else ((log(ret)/scale)/normalization_factor)
}

plot(apply(matrix(c(1:60)),1,function(t) {rate_function_1(t, 2)}), type="l",
     ylab="", xlab="Time (s)", main="Rate function r(t) #1")

rt2_norm = max(apply(matrix(c(1:60)),1,function(t) {rate_function_2(t, 1)}))
plot(apply(matrix(c(1:60)),1,function(t) {rate_function_2(t,rt2_norm)}), type="l",
     ylab="", xlab="Time (s)", main="Rate function r(t) #2")

```

### Step 1, "poor and robust" algorithm implementation

**Goal** -- The "poor and robust" algorithm is a method to generate inhomogeneous Poisson processes that trades robustness for time complexity. We will implement such an algorithm below and provide some resulting examples.

**Method** -- To implement a "poor and robust" approach, we want to simulate Bernoulli random variables such that, starting at $t=0$ and $N_0=0$, with time discretization parameter $\delta$:

\begin{align}
\forall j\in\mathbb{N},\,Z_j&\sim\mathcal{B}(r(j\delta)\delta)\\
\mathbb{P}(Z_j=1) &= r(j\delta)\delta\\
\mathbb{P}(Z_j=0) &= 1-r(j\delta)\delta\\
\hat{N}_t^\delta &= \sum_{j=0}^{\lfloor\frac{t}{\delta}\rfloor}
\end{align}

```{r inhomogeneous_poor_robust_simulation}

inhomogeneous_poor_robust_algorithm <- function(
  rate_function, normalization_factor, 
  delta_parameter, max_seconds=10
) {
  ### Generates a list of Bernouilli random variables
  ### so as to generate a inhomogeneous Poisson process
  ### simulation
  #
  # Declares the mapper function to compute the jump location
  # over a fixed list of time steps
  mapper <- function(t) {
    rbinom(1,1,rate_function(
      t*delta_parameter, normalization_factor
    )*delta_parameter)
  }
  # Declares the time steps object
  time_steps = matrix(c(0:(max_seconds/delta_parameter)))
  # Computes the state jump locations
  jumps = apply(time_steps, 1, mapper)
  jumps[is.na(jumps)]=0
  # Computes the inhomogeneous Poisson process
  N = cumsum(jumps)
  return(list("NtDelta"=N, "jumps"=jumps))
}

inhomogeneous_poor_robust_simulate <- function(
  rate_function, normalization_factor, 
  delta_parameter, n_simulations, max_seconds=10
){
  ### Generates <n_simulations> of an inhomogeneous Poisson process
  ### given the Poor and Robust algorithm
  # 
  # Generates a matrix/list from 1 to <n_simulations> to map over
  n_simulations = matrix(c(1:n_simulations))
  # Generates the simulations
  simulations = apply(n_simulations, 1, function(x){
    inhomogeneous_poor_robust_algorithm(
      rate_function, normalization_factor, delta_parameter, max_seconds
    )
  })
  simulations
}

```

Given the simulation function, we produce a plotting function to display the a simulation batch results.

```{r inhomogeneous_poor_robust_plotting}

plot_inhomogeneous_poor_robust_simulations <- function(
  poisson_processes, delta_parameter, max_seconds, 
  rate_function, normalization_factor
) {
  ### Generates a 3-plot visualization for a batch of simulations of an inhomogeneous
  ### Poisson process simulation batch.
  #
  # Retrieves the data to plot
  NtDelta = c()
  jumps = c()
  for (i in 1:length(poisson_processes)) {
    NtDelta = cbind(NtDelta, poisson_processes[[i]]$NtDelta)
    jumps = cbind(jumps, poisson_processes[[i]]$jumps)
  }
  NtDelta = NtDelta # Scales to account for delta_parameter
  # Computes the rate function data to plot
  x = matrix(seq(0, max_seconds, delta_parameter))
  y = apply(x, 1, function(t) {rate_function(t, normalization_factor)})
  
  # Plots
  par(mfrow=c(3,1), mai = c(0.35, 0.55, 0.35, 0.1))
  # Plots the rate function
  plot(x, y, main="Rate function r", type="l", xlab="",ylab="y")
  # Plots the trajectory plot for the first ten generated processes
  n_simulations = dim(NtDelta)[2]
  counters = c(0:(dim(NtDelta)[1]-1))*delta_parameter
  plot(counters, NtDelta[,1],type="S",col=2,lwd=1,
       xlab="", ylab="N (counter)",
       xlim = c(0,max_seconds),
       main=paste("Trajectories of the first 10 generated inhomogeneous Poisson processes\n",
                  "with above rate function and delta parameter ",
                  delta_parameter, sep=""))
  for (i in 2:10) {
    lines(counters, NtDelta[,i],type="S",lwd=1,col=i+1)
  }
  # Plots the raster plot
  events = list()
  for (i in 1:dim(jumps)[2]) {
    lst = jumps[,i]*counters
    events = append(events, list(lst[sapply(lst, function(x){x!=0})]))
  }
  if (length(events) >= 100) {
    events = as.repeatedTrain(events[1:100])
    title = paste0("Raster plot of the first 100 inhomogeneous\n",
             " Poisson processes with delta parameter: ", delta_parameter)
  } else {
    events = as.repeatedTrain(events)
    title = paste0("Raster plot of the generated inhomogeneous\n",
             " Poisson processes with delta parameter: ", delta_parameter)
  }
  plot(events, colStim = "grey80", main=title, 
         ylab="Trials", yaxt="n", xlab="Time (s)",
         xlim=c(0,max_seconds))
  # returns
  return(list("NtDelta"=NtDelta, "jumps"=jumps, "counters"=counters, "events"=events))
}

```

**Results** -- We can now run a set of simulations over the length of time of a single minute using the poor and robust algorithm. Using the rate_function_2 outputs warnings due to the creation of NAs -- those are replaced by 0 in the code instead.

```{r inhomogeneous_poor_robust_simulation_runs}

max_seconds = 60 
delta_parameter = 0.01
n_simulations = 100

simulation_rate_function_1 = inhomogeneous_poor_robust_simulate(
  rate_function_1, 2, delta_parameter, n_simulations, max_seconds
)
simulation_rate_function_2 = inhomogeneous_poor_robust_simulate(
  rate_function_2, rt2_norm, delta_parameter, n_simulations, max_seconds
)

```

We now can display the results:

```{r inhomogeneous_poor_robust_rf1_visualization, out.width="100%"}

sim_rf1_results = plot_inhomogeneous_poor_robust_simulations(
  simulation_rate_function_1, 
  delta_parameter, 
  max_seconds, 
  rate_function_1,
  2
)

```

```{r inhomogeneous_poor_robust_rf2_visualization, out.width="100%"}

sim_rf2_results = plot_inhomogeneous_poor_robust_simulations(
  simulation_rate_function_2, 
  delta_parameter, 
  max_seconds, 
  rate_function_2,
  rt2_norm
)

```

**Comments** -- We have based our inhomogeneous Poisson process modeling on the poor and robust algorithm distribution. Moreover, for simulation purposes, we set our generation process on a 60-second period with a delta parameter $\delta=0.01$. As such, we can visually attest of a non-homogeneous generation process (as seen above). a maximum amount of state jumps (from 0 to 1, then 1 to 2, etc.).

### Step 2, algorithm with rejection procedure implementation

**Goal** --

**Method** -- 

```{r rejection_algorithm_simulations}

inhomogeneous_rejection_simulate_v1 <- function(
  rate_function, normalization_factor, 
  delta_parameter, n_simulations, max_seconds=10
){
  ### Generates <n_simulations> of an inhomogeneous Poisson process
  ### given the rejection algorithm
  # 
  # Generates a base matrix of sequences from 0 to <max_seconds> by
  # <delta_parameter> steps
  simulations = apply(matrix(0, nrow=n_simulations),1,
                      function(x){seq(0,max_seconds,delta_parameter)})
  # Maps the rate_function over each simulations
  simulated_spikes = apply(simulations, c(1,2), 
                           function(t){rate_function(t, normalization_factor)})
  # Since the simulated spikes are based on a rate function that is normalized
  # it is equivalent to having a probability
  # Decides using a binomial draw whether to keep a spike or not by creating
  # a Boolean mask
  keep_or_reject = apply(simulated_spikes, c(1,2),
                         function(x){rbinom(1,1,x)})
  keep_or_reject[is.na(keep_or_reject)]=0
  events = list()
  for (i in 1:dim(keep_or_reject)[2]) {
    events = append(events, list(simulations[,i][as.logical(keep_or_reject[,i])]))
  }
  return(list("NtDelta"="simulations", "jumps"=""))
}

inhomogeneous_rejection_simulate_v2 <- function(
  rate_function, normalization_factor, 
  delta_parameter, n_simulations, max_seconds=10
){
  ### Generates <n_simulations> of an inhomogeneous Poisson process
  ### given the rejection algorithm
  # 
  # Generates a homogeneous Poisson process matrix
  simulations = homogeneous_poisson_process_simulation(1,1.5*max_seconds, n_simulations)
  spike_times = list()
  for (i in 1:n_simulations){
    sims = list(simulations$simulations[i,2:(1.5*max_seconds)][simulations$simulations[i,]<=max_seconds])
    spike_times = append(simulations_temp, sims)
  }
  return(list("NtDelta"="simulations", "jumps"=""))
}

```

**Results** -- We can now run a set of simulations over the length of time of a single minute with the rejection algorithm. Using the rate_function_2 outputs warnings due to the creation of NAs -- those are replaced by 0 in the code instead.

```{r inhomogeneous_poor_robust_simulation_runs}

max_seconds = 60 
delta_parameter = 0.01
n_simulations = 100

simulation_rate_function_1 = inhomogeneous_rejection_simulate(
  rate_function_1, 2, delta_parameter, n_simulations, max_seconds
)
simulation_rate_function_2 = inhomogeneous_rejection_simulate(
  rate_function_2, rt2_norm, delta_parameter, n_simulations, max_seconds
)

```

We now can display the results:

**Comments** --
