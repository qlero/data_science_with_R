---
title: "tutorial_4"
output: html_document
author: Quentin Le Roux
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Simulating a Markov Chain

### Instructions

**Two sequences of Bernoulli random variables are introduced with the following parameters:**

\begin{align}
\mathbb{P}_{0\rightarrow1}\\
\mathbb{P}_{1\rightarrow0}\\
(Y_i)_{i\in \mathcal{N}}&,\mathbb{P}(success =Y_i)=\mathbb{P}_{0\rightarrow1}\\
(Z_i)_{i\in \mathcal{N}}&,\mathbb{P}(success =Z_i)=\mathbb{P}_{1\rightarrow0}\\
Z_i, Y_i&\in\{0, 1\}\\
X_{n+1} &= X_n*(1-Z_{n+1}) + (1-X_n)*Y_{n+1}\\
X_{n+1} &= X_n*\mathbb{1}_{[\mathbb{P}_{1\rightarrow0}, 1]}(U_{n+1}) + (1-X_n)*\mathbb{1}_{[0, \mathbb{P}_{0\rightarrow1}]}(U_{n+1}\\
\text{where}&,\\
(U_n)_{n\ge1}&\sim U[0,1]\,\,\text{a sequence of IID RV}
\end{align}

**It is assumed that the two processes are independent and $Y_1, ..., Y_n$ and $Z_1, ..., Z_n$ are respectively IID.**

1. Choose an initial condition (i.e. the value of $X_0$)
2. Choose the parameters $\mathbb{P}_{0\rightarrow1}\in[0,1]$ and $\mathbb{P}_{1\rightarrow0}\in[0,1]$
3. Simulate different Markov Chains (e.g. simulate a Bernoulli sequence with one or more different methods (Bernoulli function or uniform discrete on 0, 1), i.e. $\mathcal{B}(p)\sim U[0,1]$, $Y=\mathbb{1}_{[0,p]}(U)$)
    
### Implementation
    
**1 & 2** -- We decide to always initialize our Markov Chain to $0$, and generate the jump probabilities (from state 0 to 1, and 1 to 0) as uniform variables from 0 to 1 (rounded to 2 decimals). We also specify another parameter $n$, the number of Markov Chains generated, and $t$ the length of each chain.

```{r simulation_param_function}

# Declares the jump parameters
generate_params <- function(n, t){
  # Generates a list of probability of jumping from
  # state 0 to 1, and vice-versa
  # args:   n -> the number of chains to generate
  #         t -> the length of each chain
  params = list("init"=0,"n"=n,"t"=t,
                "p0to1"=round(runif(1,0,1),2), 
                "p1to0"=round(runif(1,0,1),2))
  cat("Probability jump 0 -> 1:", params$p0to1,"\n")
  cat("Probability jump 1 -> 0:", params$p1to0)
  params
}

```

**3** -- To generate $n$ Markov Chains, we provide 2 different approaches:

- Iterative method: *Generating a 0-valued matrix of shape $n\times t$, iterates over each row and column, drawing a random uniform variable against a check dependent on the previous row-cell, to see whether to update the current cell (i.e. to jump)*
- Bernouilli sequence method: *Generating a 0-valued matrix of shape $n\times t$, generates for each column two Bernoulli sequences to be use to update (or not) each row of the column (i.e. to jump between values)*

```{r generation_functions}

simulation_v1_iterative_method <- function(params) {
  ### Generates a set of Markov Chains (version 1)
  # Initializes a matrix to the init value in params
  # rows = time step, columns = unique markov chain
  chains = matrix(params$init, 
                  nrow=params$t, 
                  ncol=params$n)
  # Declares the indicator function 1_[p]*U_{n+1}
  switch <- function(prob) {
    x = runif(1,0,1)<=prob
    x}
  # Iterates over the matrix, update
  for (row in seq(2,params$t,1)) {
    for (col in seq(1,params$n,1)){
      if (chains[row-1,col]==0 && 
          switch(params$p0to1)) {
        # if value @ t-1 is 0 & p0to1 switch is True, 
        # push next matrix entry to 1
        chains[row,col]=1
      } else if (chains[row-1,col]==1 && 
                 switch(params$p1to0)) {
        # if value @ t-1 is 1 & p1to0 switch is True, 
        # push next matrix entry to 0
        chains[row,col]=0
      } else {
        # else, duplicates value from t-1
        chains[row,col]=chains[row-1,col]
      }
    }
  }
  chains
}

simulation_v2_bernouilli_seqs <- function(params) {
  ### Generates a set of Markov Chains (version 2)
  # Initializes a matrix to the init value in params
  # rows = time step, columns = unique markov chain
  chains = matrix(params$init,
                  nrow=params$t,
                  ncol=params$n)
  # Declares a function to more explicitly state that
  # a sequence of bernoulli values from 0 to 1 are 
  # generated
  generate_bernoulli_seq <- function(p,n) {rbinom(n, 1, p)}
  # Iterates over the matrix, update
  for (col in seq(1,params$n,1)) {
    # generates two sequences Y and Z
    # we only need t-1 draws as we only update <chains>
    # starting at the index 2
    Y = generate_bernoulli_seq(params$p0to1, params$t-1)
    Z = generate_bernoulli_seq(params$p1to0, params$t-1)
    for (row in seq(1,params$t-1,1)) {
        chains[row+1, col] = chains[row,col]*(1-Z[row]) +
                             (1-chains[row,col])*Y[row]
      }
    }
  chains
}

```

With the two approaches, we can generate Markov Chains and see which of the two is the fastest using the ``system.time()`` function. To do so, we arbitrarily select a large $n$ and $t$ as we generate a set of parameters.

```{r timing_generation_functions}

params = generate_params(1000,10000)

system.time(simulation_v1_iterative_method(params))
system.time(simulation_v2_bernouilli_seqs(params))

```

We see that the second function is faster by c. one order of magnitude, which can be explained by the absence of branching conditions in the second function's body (a time consuming implementation for a processor). We will use the second function to generate Markov Chains.

To generate Markov Chains, we arbitrarily set $n=4$ and $t=25$ for data visualization purposes (we want to plot the data).


```{r generating_markov_chains}

params = generate_params(4,25)
markov_chains = simulation_v2_bernouilli_seqs(params)

head(markov_chains)

```

```{r plotting_markov_chains}

par(mfrow=c(2,2))
for (i in 1:4){
  plot(markov_chains[,i], type="l",
       main=paste("Generated Markov Chain n'", i),
       xlab="timesteps", ylab="value (either 0 or 1)")
}

```

## Topic 2 Simulating a Markov Process

### Instructions

1. Simulate $(Y_n)$ with parameters $\alpha\delta$ and $\beta\delta$.

2. Evaluate the distribution of $\tau_1^\delta=N_1\delta$ where $N_1$ is the first time $Y_1 = 1$

3. Plot the empirical distribution of $\tau_1^\delta$ for small $\delta$ and compare with the distribution of $\mathcal{E}$ with parameter $\alpha$. 

### Implementation

**1** -- To simulate $(Y_n)$ (the Markov Chain approximation of the underlying continuous time Markov Process), we start with declaring the rates $\alpha$ and $\beta$, as well as the measure accuracy parameter $\delta$. We also set an arbitrary length $t$ (the number of timesteps).

```{r markov_proc_params}

generate_MP_params <- function(n, t, a, b, d) {
  # Generates a list of probability of jumping from
  # state 0 to 1, and vice-versa
  # args:   n -> the number of chains to generate
  #         t -> the length of each chain
  params = list("init"=0,"n"=n,"t"=t,
                "alpha"=a,"beta"=b,"delta"=d,
                "p0to1"=a*d, 
                "p1to0"=b*d)
  params
}

alpha = 5
beta = 10
delta = 0.01

```

Now that the parameters have been generated, we can reuse our previously declared simulation function to generate a large amount of simulations. We select $n=10000$ and $t=100000$ arbitrarily. 

```{r simulating_Yn}

n = 1000
t = 5000
MP_params = generate_MP_params(n, t, alpha, beta, delta)
Yn_simulations = simulation_v2_bernouilli_seqs(MP_params)

```

As we have generated $Y_n$, we might want to have a preliminary view of the change of states. To do so, we pick the first four simulations:

```{r visualizing_yn_simulations}

par(mfrow=c(2,2))
for (i in 1:4){
  plot(Yn_simulations[1:500,i], type="l",
       main=paste("First 500 elements of Generated Markov Chain n'", i, 
                  "\nwith parameters alpha=5, beta=10, delta=0.01"),
       xlab="timesteps", ylab="value (either 0 or 1)")
}

```


**2** -- We now want to retrieve the index of the first time $(Y_n)$ jumps to the value $1$. We decrement all values by 1 as R is 1-indexed and we know that an exponential distribution has $\mathbb{R}_+$ for support, and we want to start at $t=0$ where the initial state is 0.

```{r retrieving_indexes}

fetch_indexes <- function(Yn, d) {
  # Retrieves the first index where 
  fetch_idx_one_simulation <- function(x){
    (c(which(x==1))[1]-1)*d 
    # we need to rescale as d is a frequency 
    # acquisition parameter, thus the (*d)
  }
  apply(Yn,2,fetch_idx_one_simulation)
}

t1_simulation = fetch_indexes(Yn_simulations, delta) # t1_simulation is our N_!

```

Now that we have $N_1$, we can evaluate the distribution of $\tau^delta_1$ where $\delta=0.01$.

```{r kd_plot_t1_simulations}

# Kernel density estimation
d <- density(t1_simulation)
# Kernel density plot
plot(d, lwd = 2, main = "Default kernel density plot")

```

**3** -- We are now interested in varying the value of the parameter $\delta$ and observe the impact on the resulting distribution of $\tau_1$. To do so, we select a sequence of values for $\delta$:

```{r}

# Declares variables
n = 5000
t = 10000
alpha = 5
beta = 10
delta_sequence = as.matrix(c(1e-1,5e-2,1e-2,5e-3,1e-3,5e-4,1e-4))

```


```{r}

mapper <- function(n, t, a, b, d) {
  fetch_indexes(
    simulation_v2_bernouilli_seqs(
      generate_MP_params(n, t, a, b, d)), d)
}

t1_simulations = apply(delta_sequence, 1, 
                       function(x) {mapper(n,t,alpha,beta,x)})

```


```{r}

par(mfrow=c(2,3))
for (i in 1:6){
  cat(i)
  d <- density(t1_simulations[,i])
  # Kernel density plot
  plot(d, lwd = 2, main = "Default kernel density plot")
}

```



